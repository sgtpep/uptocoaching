#!/usr/bin/env node
const autoprefixer = require('autoprefixer');
const child_process = require('child_process');
const csso = require('csso');
const fs = require('fs');
const postcss = require('postcss');
const postcssImport = require('postcss-import');
const postcssURL = require('postcss-url');
const posthtml = require('posthtml');
const posthtmlInlineAssets = require('posthtml-inline-assets');
const rollup = require('rollup');
const rollupBabel = require('rollup-plugin-babel');
const rollupCommonJS = require('rollup-plugin-commonjs');
const rollupNodeResolve = require('rollup-plugin-node-resolve');
const UglifyJS = require('uglify-js');

const cache = { scripts: {}, styles: {} };

const filterMime = (mime, file) =>
  file.endsWith('.svg') ? 'image/svg+xml' : mime;

const indices = () =>
  child_process
    .spawnSync(
      'find',
      [
        '-type',
        'f',
        '-name',
        'index.html',
        '!',
        '-regex',
        String.raw`\./\(\..+\|node_modules\)/.+`,
      ],
      { encoding: 'utf8' },
    )
    .stdout.split('\n')
    .slice(0, -1);

const main = () =>
  indices().reduce(
    (promise, index) =>
      promise.then(
        () => processHTML(index),
        error => {
          console.error(error);
          process.exit(1);
        },
      ),
    Promise.resolve(),
  );

const parseStyle = style =>
  style
    .split(';')
    .map(declaration =>
      declaration.split(':', 2).map(component => component.trim()),
    );

const processHTML = index =>
  posthtml([
    posthtmlInlineAssets({
      errors: 'throw',
      transforms: {
        image: { resolve: resolveImage, transform: transformImage },
        script: { resolve: resolveScript, transform: transformScript },
        style: { resolve: resolveStyle, transform: transformStyle },
      },
    }),
  ])
    .process(fs.readFileSync(index))
    .then(result => fs.writeFileSync(index, result.html));

const resolveImage = node =>
  node.tag === 'img' && node.attrs && testURL(node.attrs.src);

const resolveScript = node =>
  node.tag === 'script' && node.attrs && testURL(node.attrs.src);

const resolveStyle = node =>
  node.tag === 'link' &&
  node.attrs &&
  node.attrs.rel === 'stylesheet' &&
  testURL(node.attrs.href);

const testURL = url => /^(https?:|)\/\//.test(url) || url;

const transformImage = (node, data) => {
  node.attrs.src = `data:${filterMime(
    data.mime,
    data.from,
  )};base64,${data.buffer.toString('base64')}`;
};

const transformScript = (node, data) => {
  delete node.attrs.src;
  delete node.attrs.type;
  if (data.from in cache.scripts) {
    node.content = cache.scripts[data.from];
  } else {
    return rollup
      .rollup({
        input: data.from,
        plugins: [
          rollupBabel({
            ignore: ['./node_modules'],
            presets: [['@babel/env', { useBuiltIns: 'usage' }]],
          }),
          rollupCommonJS(),
          rollupNodeResolve(),
        ],
      })
      .then(bundle => bundle.generate({ format: 'iife' }))
      .then(output => {
        node.content = UglifyJS.minify(output.code).code;
        cache.scripts[data.from] = node.content;
      });
  }
};

const transformStyle = (node, data) => {
  delete node.attrs.href;
  delete node.attrs.rel;
  node.tag = 'style';
  if (data.from in cache.styles) {
    node.content = cache.styles[data.from];
  } else {
    return postcss([
      postcssImport(),
      autoprefixer(),
      postcssURL({ url: 'inline' }),
    ])
      .process(data.buffer.toString('utf8'), { from: data.from })
      .then(output => {
        node.content = csso.minify(output.css).css;
        cache.styles[data.from] = node.content;
      });
  }
};

main();
